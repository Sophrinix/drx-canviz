<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="Cache-Control" content="no-cache">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>DrX -- The Good Doctor</title>
<link rel="stylesheet" href="index.css?a" type="text/css">
</head>

<h1>DrX</h1>

<div class="gallery">
<h2>Gallery</h2>
  <a href="314.png"><img width="300" height="255" src="314_thumb.png" /></a>
    <br /> <br />
  <a href="file.png"><img width="300" height="255" src="file_thumb.png" /></a>
</div>

<p>DrX, the good doctor, is a small <em>object inspector</em> for Ruby.

<p>Instead of focusing on the <em>contents</em> of your object, DrX
instead focuses on its <em>object model</em>. As a result, DrX
is most suitable for programmers wishing to understand Ruby's object
model better. It's especially adept at showing you how a "magical"
library works (e.g., an ORM like DataMapper or ActiveRecord).</p>

<h2>Key features:</h2>

<ul>
<li>See everything about a Ruby object: its 'klass', 'super',
'iv_tbl', 'm_tbl'. See your singletons with your very own eyes! <br />&nbsp;</li>

<li>Double-click a method to launch an editor
and position the cursor on the exact line where the method is
defined!</li>
</ul>

<h2>Installation</h2>

<p>DrX is shipped as a gem. At your system prompt type:</p>

<code>gem install drx</code>

<h2>Usage</h2>

<p>Just <code>require 'drx'</code> in your program and do
<code>some_object.see</code> to investigate that object:</p>

<pre>
require 'rubygems'
require 'drx'

"wizard of oz".see

Math::PI.see

s = "wizard of oz"
def s.strong
  "&lt;strong&gt;" + self + "!&lt;/strong&gt;"
end
s.see
</pre>

<p>And see the <a href="#key-bindings">Key bindings</a> section.</p>

<h2>Requirements</h2>

<ol>
<li>MRI Ruby 1.8 or 1.9.</li>
<li>Ability to compile Ruby C extensions (Because DrX has some part written in C).</li>
<li>The Tk user interface toolkit.
  <div class="further">
    <p>You can use either the "new" Tk (version 8.5), or the "old" one (version 8.4).</p>
    <p>However, if you use the "old" one, you must also have the Tile extension installed.
    For example, on Ubuntu do <code>sudo apt-get install tk-tile</code>. Alternatively, as a very last
    resort, use an old version of DrX which doesn't necessitates Tile
    (that's any version earlier than 0.4).</p>
  </div>
  </li>
<li>The <a href="http://www.graphviz.org/">GraphViz</a> package (It's used to draw the diagrams).
  <div class="further">
    <p>If the graphs DrX produces have ragged lines, it means your GraphViz doesn't have
    anti-aliasing support. A quick way to solve this on Ubuntu is by doing
    <code>sudo apt-get install graphviz-cairo</code>.</p>
    <p>Make sure GraphViz' 'bin' folder is in your $PATH.</p>
  </div>
  </li>
</ol>

<p>(A note to MS-Windows users: DrX was installed sucessfully under: RubyInstaller + DevKit; Tk
from ActiveState and bindings via <a href="http://github.com/rdp/tk_as_gem">tk_as_gem</a>.)</p>

<h2>Recommendations</h2>

<p>DrX <a href="#arguments">can show you the arguments</a> methods expect. While this is not
needed, DrX can work more effectively if you install the "arguments"
and/or the "methodpara" gems. In short, do <code>gem install
rdp-arguments</code> and <code>gem install methopara</code>.</p>

<h2>The object graph</h2>

<p>The object graph shows the object model. Ruby objects have two "pointers":</p>

<ol>
<li><em>klass</em>, which points to the class of an object.</li>
<li><em>super</em>, which points to the parent of a class.</li>
</ol>

<p>Correspondingly, the object graph shows [at most] two arrows pointing
out of an object: the <em>klass</em> arrow is shown as a dotted arrow,
and is usually pointing to the right (horizontal); and the <em>super</em> arrow is
shown as a solid arrow, and is usually pointing down (vertical).</p>

<p>When you see a horizontal arrow, think of it as "here are the methods
the object responds to"; and when you see a vertical one, think "here are
additional methods".</p>

<h3>Colors and shapes</h2>

<ul>
<li class="color-module">Modules are shown in green</li>
<li class="color-class">Classes are blue ovals. <span class="color-singleton">Singletons are darker, and have "'S" appended to their label.</span></li>
<li class="color-object">Mere objects are brownish houses.</li>
</ul>

<p>(This is true for the default style only.)</p>

<h2>The variables table</h2>

<p>A Ruby object has a <em>variables table</em> associated with it. The
variables pane lists the content of this table. It is customary to think
of this table as holding instance <code>@variables</code> <code>@like</code>
<code>@this</code>, but in fact Ruby stores here also constants
("namespaces") and <code>@@class_variables</code>. The pane shows the raw
contents of this table.</p>

<h2>The methods table</h2>

<p>A Ruby object, if it's a class or a module, also holds methods. These
are stored in a <em>methods table</em>. The methods pane shows the contents of
this table.</p>

<h2>Example 1: Seeing things</h2>

For our first example, let's suppose you have the following DataMapper code...

<pre>
require 'rubygems'
require 'dm-core'

#
# This is part of a blogging website. Users write posts. A post
# belongs to a user.
#

class Post
  include DataMapper::Resource

  property :post_id,  Serial
  property :title,    String
  property :body,     Text

  belongs_to :user
end

class User
  include DataMapper::Resource

  property :user_uid,  Serial
  property :name,      String
  property :mail,      String
end
</pre>

<p>...and you wish to know what a Post object consists of. You'd append the following code...</p>

<pre>
post = Post.new

require 'drx'
post.see

# Or just do Post.see
</pre>

<p>...and you'd get a window showing you the following graph (click to
enlarge).</p>

<div align="center">
  <a href="datamapper.png"><img width="500" height="444"
    src="datamapper_thumb.png" title="Screenshot showing DrX in action" /></a>
</div>

<p>In the graph you'll notice two distinct lines of hierarchy. One describes the
Post class: most importantly it contains the
<em>DataMapper::Resource</em> module. The other line describes the Post
class' singleton: most importantly it contains the
<em>DataMapper::Model</em> module. Take a moment to click these two
modules and examine the methods they contain.</p>

<h2>Example 2: Investigating things</h2>

<p>Let's talk more about our Post class. We merely did <code>include
DataMapper::Resource</code> in its body and we see that it's acquired
gazillions of things. We want to know why this had happened.
Specifically, we want to know how DataMapper::Model got there. We
suspect that DataMapper::Resource does this magic in its
<code>#included</code>, and we want to verify this theory.</p>

<p>In other words, we want to peek into DataMapper::Resource's
singleton. Click the "DataMapper::Resource 'S" oval (that's the
singleton) to inspect its methods:</p>

<div align="center">
  <a href="editor.png"><img width="500" height="375"
    src="editor_thumb.png" title="Screenshot showing DrX in action" /></a>
</div>

<p>Aha! We see that it indeed has an <code>included</code> method
defined. Double click on the method to open it up in an editor (as
demonstrated in the screenshot). Yep, our suspicion was correct: the
<em>Model</em> module is added to our Post class by
<code>Resource.included</code>. The mystery is solved!</p>

<h2>Example 3: Sinatra</h2>

<p>Launch DrX's GUI (for example, by doing <code>''.see</code>). At the
eval line type <code>require 'sinatra'</code>. Then type <code>see
Sintra</code>. In the variables table you'll see all the sub-modules and
classes defined under the Sinatra module. Double-click any of them to
investigate it. When you're finished with one, right-click over the
graph to go back.</p>

<h2>Understanding DrX</h2>

<p>Here is how objects are defined internally in MRI ruby (from ruby.h):</p>

<pre>
struct RBasic {
    unsigned long flags;
    VALUE klass;
};

struct RObject {
    struct RBasic basic;
    struct st_table *iv_tbl;
};

struct RClass {
    struct RBasic basic;
    struct st_table *iv_tbl;
    struct st_table *m_tbl;
    VALUE super;
};
</pre>

<p>What DrX does is show you these four slots: the 'klass', the 'super',
the 'iv_tbl', and the 'm_tbl'.</p>

<h2 id="key-bindings">Key bindings</h2>

<dl>

<dt>The object graph</dt>
<dd>
  <ul>
  <li><span class="gist">Click</span> an object in the diagram to <span class="gist">select</span> this object. This updates the variables and methods panes to reflect this object.
      <ul><li>Alternatively, you can select objects by holding down the <span class="gist">control key while moving</span> the mouse. This is useful for quickly skimming through the objects without straining your hands.</li></ul></li>
  <li><span class="gist">Right-click</span> to move <span class="gist">back</span> in history.</li>
  <li><span class="gist">Double-click</span> an object in the diagram to make this object the <span class="gist">tip</span> of the diagram.
      Why is this useful?
      <ul>
      <li>To set the 'self' for the eval line.</li>
      <li>To see the "real" module behind an included one.</li>
      </ul>
  </li>
  <li><span class="gist">Scrolling</span> in the diagram is done by:
      <ul>
      <li>The mouse <span class="gist">wheel</span>. (Hold down <span class="gist">shift</span> to scroll sideways.)</li>
      <li>Dragging with the <span class="gist">middle</span> mouse button.</li>
      </ul>
  </li>
  </ul>
</dd>

<dt>The variables table</dt>
<dd>
  <ul>
  <li><span class="gist">Double-click</span> a variable to "<span class="gist">see</span>" it.</li>
  <li><span class="gist">Click</span> a variable to <span class="gist">pp()</span> it.</li>
  <li><span class="gist">Right-click</span> a variable to <span class="gist">p()</span> it.</li>
  </ul>
</dd>

<dt>The methods table</dt>
<dd>
  <ul>
  <li><span class="gist">Double-click</span> a method to bring up an <span class="gist">editor</span> showing it.</li>
  </ul>
</dd>

<dt>Between the panes</dt>
<dd>
  <ul>
  <li><span class="gist">Click-drag</span> the bars between the panes to <span class="gist">resize</span> the panes.</li>
  </ul>
</dd>

<dt>Eval input line</dt>
<dd>
  <ul>
  <li><span class="gist">Enter</span> to <span class="gist">eval()</span> the code you've typed in the input line.</li>
  <li><span class="gist">Arrow-up</span> and <span class="gist">Arrow-down</span> to move in the input line <span class="gist">history</span>.</li>
  </ul>
</dd>

<dt>Anywhere</dt>
<dd>
  <ul>

  <li><span class="gist">Control-L</span> moves the keyboard focus to the eval <span class="gist">input</span> line.
   (It should be easy to remember this: most web browsers use this key to focus on the address bar.)</li>
  <li><span class="gist">Control-R</span> <span class="gist">refreshes</span> the display. Useful if you eval'ed some code that changes the object inspected.</li>
  </ul>
</dd>

</dl>

<h2>Launching an editor</h2>

<p>When you double-click a method, DrX launches the command <code>gedit +%d "%s"</code>
by default (%d and %s are substituted by the line-number
and file-name). If you wish to use some other editor, set your
'DRX_EDITOR_COMMAND' environment variable accordingly (or see the next section).</p>

<p>Note that <em>gedit</em> has a bug: it positions the cursor on the
correct line, but sometimes it doesn't update the display and still shows the
first page of the file. If this happens, click arrow-up, then
arrow-down, to update the display. Or use some other editor.</p>

<p>DrX figures out a method's location by inspecting Ruby's internal
nodes. This functionality is contained in a small C extension built when
you install the DrX gem.</p>

<p>Of course, DrX can't figure out the location of a method written in C.</p>

<h2>The ~/.drxrc file</h2>

DrX lets you put your customizations in the file <code>~/.drxrc</code>. Here's an example:

<pre>
class Drx::TkGUI::Application
  def user_customizations
    @eval_result.height = 8
    @graph_opts[:size] = '60%'
    @graph_opts[:style] = 'crazy'

    # Turn on the "Show arguments" checkbox.
    @arguments_chk.variable.value = 1
  end
end

Drx::TkGUI::EDITOR_COMMAND.replace('gvim +%d "%s"')
</pre>

<h2 id="arguments">Method arguments</h2>

<p>When you check the "Show arguments" checkbox, DrX shows the arguments
the methods expect. DrX uses three different strategies to detect these arguments:</p>

<dl>

<dt>"methopara"</dt>
<dd>On Ruby 1.9.2, or (for earlier 1.9 Rubies) where the "methopara" gem
is installed, there's <code>Mathod#paramaters</code> to tell us about
the arguments.</dd>

<dt>RubyParser</dt>
<dd>On Ruby 1.8 and 1.9, if the "arguments" gem is installed, DrX can use
it to detect the arguments. In turn, that gem uses the RubyParser gem.</dd>

<dt>arity</dt>
<dd>If none of the above is available, DrX uses the arity of a method to
simulate its arguments. For example, if the arity is 2, the arguments reported
will be "arg, arg"; if the arity is -2, then "arg, *args" will be
reported. This strategy is the fallback in case any of the other ones fail.</dd>

</dl>

<p>The RubyParser strategy is slow, so it's only used it you explicitly
check the "Use RubyParser" checkbox.</p>

<h2>Reporting bugs</h2>

<p>Please file bug reports and support requests at the <a
href="http://github.com/mooffie/drx/issues">issue queue</a>.</p>
