<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="Cache-Control" content="no-cache">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<style type="text/css">
.gist {
  background: #ccffcc;
}
em {
  font-weight: bold;
}
.color-module {
  background: #7fffd4; /* aquamarine */
}
.color-class {
  background: #bfefff; /* lightblue1 */
}
.color-object {
  background: #ffe7ba; /* wheat1 */
}
</style>
<title>DrX -- The Good Doctor</title>
<link rel="stylesheet" href="index.css" type="text/css">
</head>

<h1>DrX</h1>

<a href="screenshot1.png"><img align="right" width="400" height="410" class="main"
  src="screenshot1.png" title="Screenshot showing DrX in action" /></a>

<p>DrX, the good doctor, is a small <em>object inspector</em> for Ruby.

<p>Instead of focusing on the <em>contents</em> of your object, DrX
instead focuses on its <em>object model</em>. As a result, DrX
is most suitable for programmers wishing to understand Ruby's object
model better. It's especially adept at showing you how a "magical"
library works (e.g. ActiveRecord).</p>

<h2>Key features:</h2>

<ul>
<li>See everything about a Ruby object: its 'klass', 'super',
'iv_tbl', 'm_tbl'. See your singletons with your very own eyes! <br />&nbsp;</li>

<li>Double-click a method to launch an editor
and position the cursor on the exact line where the method is
defined!</li>
</ul>

<h2>Installation</h2>

<p>DrX is shipped as a gem. At your system prompt type:</p>

<code>gem install drx</code>

<h2>Usage</h2>

<p>Just <code>require 'drx'</code> in your program and do
<code>some_object.see</code> to investigate that object:</p>

<pre>
require 'rubygems'
require 'drx'

"wizard of oz".see

Math::PI.see

s = "wizard of oz"
def s.strong
  "&lt;strong&gt;" + self + "!&lt;/strong&gt;"
end
s.see
</pre>

<p>And see the <a href="#key-bindings">Key bindings</a> section at the bottom.</p>

<h2>Requirements</h2>

<ul>
<li>MRI Ruby 1.8 (Code wasn't yet ported to Ruby 1.9).</li>
<li>Ability to compile Ruby C extenstions (Because DrX has some part written in C).</li>
<li>The Tk user interface toolkit.</li>
<li>The <a href="todo-update-this-link">graphviz</a> package installed (It's used to draw the diagrams).</li>
</ul>

<h2>The object graph</h2>

<p>The object graph shows the object model. Ruby objects have two "pointers":</p>

<ol>
<li><em>klass</em>, which points to the class of an object.</li>
<li><em>super</em>, which points to the parent of a class.</li>
</ol>

<p>Correspondingly, the object graph shows [at most] two arrows pointing
out of an object: the <em>klass</em> arrow is shown as a dotted arrow,
and is usually pointing to the right (horizontal); and the <em>super</em> arrow is
shown as a solid arrow, and is usually pointing down (vertical).</p>

<p>When you see a hoizontal arrow, think of it as "here are the methods
my object responds to"; and when you see a vertical one, think "here are
additional methods".</p>

<h3>Colors and shapes</h2>

<ul>
<li class="color-module">Modules are shown in green</li>
<li class="color-class">Classes are blue ovals. Singletons are blue eggs, and have "'S" appended to their label.</li>
<li class="color-object">Mere objects are brownish houses.</li>
</ul>

<h2>The variables table</h2>

<p>A Ruby object has a <em>variables table</em> associated with it. The
variables pane lists the content of this table. It is customary to think
of this table as holding instance <code>@variables</code> <code>@like</code>
<code>@this</code>, but in fact Ruby stores here also constants
("namespaces") and <code>@@class_variables</code>. The pane shows the raw
contents of this table.</p>

<h2>The methods table</h2>

<p>A Ruby object, if it's a class or a module, also holds methods. These
are stored in a <em>methods table</em>. The methods pane shows the contents of
this table.</p>

<h2>Example 1: Seeing things</h2>

For our first example, let's suppose you have the following DataMapper code...

<pre>
require 'rubygems'
require 'dm-core'

#
# This is part of a blogging website. Users write posts. A post
# belongs to a user.
#

class Post
  include DataMapper::Resource

  property :post_id,  Serial
  property :title,    String
  property :body,     Text

  belongs_to :user
end

class User
  include DataMapper::Resource

  property :user_uid,  Serial
  property :name,      String
  property :mail,      String
end
</pre>

<p>...and you wish to know what a Post object consists of. You'd append the following code...</p>

<pre>
post = Post.new

require 'drx'
post.see

# Or just do Post.see
</pre>

<p>...and you'd get the window shown in the screenshot above (click to
enlarge).</p>

<p>In the graph you'll notice two distinct lines of hierarchy. One describes the
Post class: most importanly it contains the
<em>DataMapper::Resource</em> class. The other line describes the Post
class' singleton: most importanly it contains the
<em>DataMapper::Model</em> class. Take a minute to click these two
classes and examine the methods they contain.</p>

<p>(The screenshot happens to have the DataMapper::Model class selected.
You can see the 'find_by_sql' and 'property' method on the right. ::UPDATE::)</p>

<h2>Example 2: Investigating things</h2>

<p>Let's talk more about our Post class. We only did <code>include
DataMapper::Resource</code> in its body and we see that it's acquired
gazillions of things. We want to know why this had happened.
Specifically, we want to know how DataMapper::Model got there. We
suspect that DataMapper::Resource does this magic in its
<code>#included</code>, and we want to verify this theory.</p>

<p>Let's inspect DataMapper::Resource more closely. Double-click the
"include DataMapper::Resource" box. In the new graph you'll see a
<em>klass</em> arrow pointing right; it's pointing to the singleton of
the module. (Why wasn't this shown in the previous graph? Because DrX
doesn't show <em>klass</em>es of anonymous classes and of singletons, to
prevent clutter). Click this singleton to inspect its methods:</p>

<p>::SCR::</p>

<p>Aha! We see that it indeed has an <code>included</code> method defined.
Doule click it to open it up in an editor:</p>

<div align=center>
  <a href="screenshot2.png"><img width="530" height="380"
    src="screenshot2.png" title="Screenshot showing DrX in action" /></a>
</div>

<p>Yep, our suspicion was correct: the <em>Model</em> class is added to the
singleton in <code>Resource.included</code>. The mystery was solved!</p>

<p>(You can now navigate to <code>DataMapper::Model.extended</code> and see how the other classes are added.)</p>

<h2>Understanding DrX</h2>

<p>Here is how objects are defined internally in MRI ruby (from ruby.h):</p>

<pre>
struct RBasic {
    unsigned long flags;
    VALUE klass;
};

struct RObject {
    struct RBasic basic;
    struct st_table *iv_tbl;
};

struct RClass {
    struct RBasic basic;
    struct st_table *iv_tbl;
    struct st_table *m_tbl;
    VALUE super;
};
</pre>

<p>What DrX does is show you these four slots: the 'klass', the 'super',
the 'iv_tbl', and the 'm_tbl'.</p>

<h2 id="key-bindings">Key bindings</h2>

<dl>

<dt>The object graph pane</dt>
<dd>
  <ul>
  <li><span class="gist">Left-click</span> an object in the diagram to <span class="gist">select</span> this object. This updates the variables and methods panes to reflect this object.
      <ul><li>Alternatively, you can select objects by pressing <span class="gist">Control while moving</span> the mouse. This is useful for quickly skimming through the objects without straining your hands.</li></ul></li>
  <li><span class="gist">Right-click</span> to move <span class="gist">back</span> in history.</li>
  <li><span class="gist">Double Left-click</span> an object in the diagram to make this object the <span class="gist">tip</span> of the diagram.
      Why is this useful?
      <ul>
      <li>To set the 'self' for the eval line.</li>
      <li>To see the 'klass' of an included module (in
      other words, if you want to see "the singleton of a module"), because
      this singleton is the 'klass' of an T_ICLASS (anonymous class) and the UI
      by default doesn't show it to prevent clutter.</li>
      </ul>
  </li>
  <li><span class="gist">Scrolling</span> in the diagram is done by:
      <ul>
      <li>The mouse <span class="gist">wheel</span> (possibly together with <span class="gist">shift</span>).</li>
      <li>Dragging with the <span class="gist">middle</span> mouse button.</li>
      </ul>
  </li>
  </ul>
</dd>

<dt>The variables pane</dt>
<dd>
  <ul>
  <li><span class="gist">Double left-click</span> a variable to "<span class="gist">see</span>" it.</li>
  <li><span class="gist">Left-click</span> a variable to <span class="gist">p()</span> it.</li>
  <li><span class="gist">Right-click</span> a variable to <span class="gist">pp()</span> it.</li>
  </ul>
</dd>

<dt>The methods pane</dt>
<dd>
  <ul>
  <li><span class="gist">Double-click</span> a method to bring up an <span class="gist">editor</span> showing it.</li>
  </ul>
</dd>

<dt>Between the panes</dt>
<dd>
  <ul>
  <li><span class="gist">Click-drag</span> the bars between the panes to <span class="gist">resize</span> the panes.</li>
  </ul>
</dd>

<dt>Eval input line</dt>
<dd>
  <ul>
  <li><span class="gist">Enter</span> to <span class="gist">eval()</span> the code you've typed in the input line.</li>
  <li><span class="gist">Arrow-up</span> and <span class="gist">Arrow-down</span> to move in the input line <span class="gist">history</span>.</li>
  </ul>
</dd>

<dt>Anywhere</dt>
<dd>
  <ul>
  <li><span class="gist">Control-R</span> <span class="gist">refreshes</span> the display. Useful if you eval'ed some code that changes the object inspected.</li>
  <li><span class="gist">Control-L</span> moves the keyboard focus to the eval <span class="gist">input</span> line.</li>
  </ul>
</dd>

</dl>

<h2>Launching an editor</h2>

<p>When you double-click a method, DrX launches the command <code>gedit +%d "%s"</code>
by default (%d and %s are substituted by the line-number
and file-name). If you wish to use some other editor, set your
'DRX_EDITOR_COMMAND' environment variable accordingly.</p>

<p>DrX figures out a method's location by inspecting Ruby's internal
nodes. This functionality is contained in a small C extension built when
you install the DrX gem.</p>

<p>Of course, DrX can't figure out the location of a method defined in C.</p>

<h2>Reporting bugs</h2>

<p>Please file bugs and support requests at the RubyForge <a href="http://rubyforge.org/projects/drx/">website</a>.</p>
