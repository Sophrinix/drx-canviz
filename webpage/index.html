<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="Cache-Control" content="no-cache">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<style type="text/css">
.gist {
  background: #ccffcc;
}
em {
  font-weight: bold;
}

.color-module {
  background: #7fffd4; /* aquamarine */
}
.color-class {
  background: #bfefff; /* lightblue1 */
}
.color-singleton {
  background: #87ceff; /* skyblue1 */
}
.color-object {
  background: #ffe7ba; /* wheat1 */
}

div.gallery {
  float: right;
  background: #eee;
  border: 1px #888 solid;
  padding: 1em;
  margin-left: 1.5em;
}
div.gallery h2 {
  font-family: serif;
  font-style: italic;
  text-align: center;
}

.further {
  color: #aaa;
  margin-left: 1em;
}
</style>
<title>DrX -- The Good Doctor</title>
<link rel="stylesheet" href="index.css" type="text/css">
</head>

<h1>DrX</h1>

<div class="gallery">
<h2>Gallery</h2>
  <a href="314.png"><img width="300" height="255" src="314_thumb.png" /></a>
    <br /> <br />
  <a href="file.png"><img width="300" height="255" src="file_thumb.png" /></a>
</div>

<p>DrX, the good doctor, is a small <em>object inspector</em> for Ruby.

<p>Instead of focusing on the <em>contents</em> of your object, DrX
instead focuses on its <em>object model</em>. As a result, DrX
is most suitable for programmers wishing to understand Ruby's object
model better. It's especially adept at showing you how a "magical"
library works (e.g. ActiveRecord).</p>

<h2>Key features:</h2>

<ul>
<li>See everything about a Ruby object: its 'klass', 'super',
'iv_tbl', 'm_tbl'. See your singletons with your very own eyes! <br />&nbsp;</li>

<li>Double-click a method to launch an editor
and position the cursor on the exact line where the method is
defined!</li>
</ul>

<h2>Installation</h2>

<p>DrX is shipped as a gem. At your system prompt type:</p>

<code>gem install drx</code>

<h2>Usage</h2>

<p>Just <code>require 'drx'</code> in your program and do
<code>some_object.see</code> to investigate that object:</p>

<pre>
require 'rubygems'
require 'drx'

"wizard of oz".see

Math::PI.see

s = "wizard of oz"
def s.strong
  "&lt;strong&gt;" + self + "!&lt;/strong&gt;"
end
s.see
</pre>

<p>And see the <a href="#key-bindings">Key bindings</a> section at the bottom.</p>

<h2>Requirements</h2>

<ol>
<li>MRI Ruby 1.8 (Code wasn't yet ported to Ruby 1.9).</li>
<li>Ability to compile Ruby C extenstions (Because DrX has some part written in C).</li>
<li>The Tk user interface toolkit.
  <div class="further">
    <p>You can use either the "new" Tk (version 8.5), or the "old" one (version 8.4).</p>
    <p>However, if you use the "old" one, you must also have the Tile extension installed.
    For exmaple, on Ubuntu do <code>sudo apt-get install tk-tile</code>. As a very last
    resort, use an older version of DrX (earlier than 0.4), which doesn't necessiates Tile.</p>
  </div>
  </li>
<li>The <a href="http://www.graphviz.org/">graphviz</a> package installed (It's used to draw the diagrams).
  <div class="further">
    <p>If the graphs DrX produces have ragged lines, it means your GraphViz doesn't have
    antialiasing support. A quick way to solve this on Ubuntu is by doing
    <code>sudo apt-get install graphviz-cairo</code>.
    </p>
  </div>
  </li>
</ol>

<h2>The object graph</h2>

<p>The object graph shows the object model. Ruby objects have two "pointers":</p>

<ol>
<li><em>klass</em>, which points to the class of an object.</li>
<li><em>super</em>, which points to the parent of a class.</li>
</ol>

<p>Correspondingly, the object graph shows [at most] two arrows pointing
out of an object: the <em>klass</em> arrow is shown as a dotted arrow,
and is usually pointing to the right (horizontal); and the <em>super</em> arrow is
shown as a solid arrow, and is usually pointing down (vertical).</p>

<p>When you see a hoizontal arrow, think of it as "here are the methods
my object responds to"; and when you see a vertical one, think "here are
additional methods".</p>

<h3>Colors and shapes</h2>

<ul>
<li class="color-module">Modules are shown in green</li>
<li class="color-class">Classes are blue ovals. <span class="color-singleton">Singletons are darker, and have "'S" appended to their label.</span></li>
<li class="color-object">Mere objects are brownish houses.</li>
</ul>

<h2>The variables table</h2>

<p>A Ruby object has a <em>variables table</em> associated with it. The
variables pane lists the content of this table. It is customary to think
of this table as holding instance <code>@variables</code> <code>@like</code>
<code>@this</code>, but in fact Ruby stores here also constants
("namespaces") and <code>@@class_variables</code>. The pane shows the raw
contents of this table.</p>

<h2>The methods table</h2>

<p>A Ruby object, if it's a class or a module, also holds methods. These
are stored in a <em>methods table</em>. The methods pane shows the contents of
this table.</p>

<h2>Example 1: Seeing things</h2>

For our first example, let's suppose you have the following DataMapper code...

<pre>
require 'rubygems'
require 'dm-core'

#
# This is part of a blogging website. Users write posts. A post
# belongs to a user.
#

class Post
  include DataMapper::Resource

  property :post_id,  Serial
  property :title,    String
  property :body,     Text

  belongs_to :user
end

class User
  include DataMapper::Resource

  property :user_uid,  Serial
  property :name,      String
  property :mail,      String
end
</pre>

<p>...and you wish to know what a Post object consists of. You'd append the following code...</p>

<pre>
post = Post.new

require 'drx'
post.see

# Or just do Post.see
</pre>

<p>...and you'd get a window showing you the following graph (click to
enlarge).</p>

<div align="center">
  <a href="datamapper.png"><img width="500" height="444"
    src="datamapper_thumb.png" title="Screenshot showing DrX in action" /></a>
</div>

<p>In the graph you'll notice two distinct lines of hierarchy. One describes the
Post class: most importanly it contains the
<em>DataMapper::Resource</em> module. The other line describes the Post
class' singleton: most importanly it contains the
<em>DataMapper::Model</em> module. Take a moment to click these two
modules and examine the methods they contain.</p>

<h2>Example 2: Investigating things</h2>

<p>Let's talk more about our Post class. We only did <code>include
DataMapper::Resource</code> in its body and we see that it's acquired
gazillions of things. We want to know why this had happened.
Specifically, we want to know how DataMapper::Model got there. We
suspect that DataMapper::Resource does this magic in its
<code>#included</code>, and we want to verify this theory.</p>

<p>In other words, we want to peek into DataMapper::Resource's
singleton. Click the "DataMapper::Resource 'S" oval (this is the
singleton) to inspect its methods:</p>

<div align="center">
  <a href="editor.png"><img width="500" height="375"
    src="editor_thumb.png" title="Screenshot showing DrX in action" /></a>
</div>

<p>Aha! We see that it indeed has an <code>included</code> method
defined. Doule click on the method to open it up in an editor (as
demonstrated in the screenshot). Yep, our suspicion was correct: the
<em>Model</em> module is added to our Post class in
<code>Resource.included</code>. The mystery was solved!</p>

<h2>Understanding DrX</h2>

<p>Here is how objects are defined internally in MRI ruby (from ruby.h):</p>

<pre>
struct RBasic {
    unsigned long flags;
    VALUE klass;
};

struct RObject {
    struct RBasic basic;
    struct st_table *iv_tbl;
};

struct RClass {
    struct RBasic basic;
    struct st_table *iv_tbl;
    struct st_table *m_tbl;
    VALUE super;
};
</pre>

<p>What DrX does is show you these four slots: the 'klass', the 'super',
the 'iv_tbl', and the 'm_tbl'.</p>

<h2 id="key-bindings">Key bindings</h2>

<dl>

<dt>The object graph pane</dt>
<dd>
  <ul>
  <li><span class="gist">Left-click</span> an object in the diagram to <span class="gist">select</span> this object. This updates the variables and methods panes to reflect this object.
      <ul><li>Alternatively, you can select objects by pressing <span class="gist">Control while moving</span> the mouse. This is useful for quickly skimming through the objects without straining your hands.</li></ul></li>
  <li><span class="gist">Right-click</span> to move <span class="gist">back</span> in history.</li>
  <li><span class="gist">Double Left-click</span> an object in the diagram to make this object the <span class="gist">tip</span> of the diagram.
      Why is this useful?
      <ul>
      <li>To set the 'self' for the eval line.</li>
      <li>To see the "real" module behind an included one.</li>
      </ul>
  </li>
  <li><span class="gist">Scrolling</span> in the diagram is done by:
      <ul>
      <li>The mouse <span class="gist">wheel</span> (possibly together with <span class="gist">shift</span>).</li>
      <li>Dragging with the <span class="gist">middle</span> mouse button.</li>
      </ul>
  </li>
  </ul>
</dd>

<dt>The variables pane</dt>
<dd>
  <ul>
  <li><span class="gist">Double left-click</span> a variable to "<span class="gist">see</span>" it.</li>
  <li><span class="gist">Left-click</span> a variable to <span class="gist">p()</span> it.</li>
  <li><span class="gist">Right-click</span> a variable to <span class="gist">pp()</span> it.</li>
  </ul>
</dd>

<dt>The methods pane</dt>
<dd>
  <ul>
  <li><span class="gist">Double-click</span> a method to bring up an <span class="gist">editor</span> showing it.</li>
  </ul>
</dd>

<dt>Between the panes</dt>
<dd>
  <ul>
  <li><span class="gist">Click-drag</span> the bars between the panes to <span class="gist">resize</span> the panes.</li>
  </ul>
</dd>

<dt>Eval input line</dt>
<dd>
  <ul>
  <li><span class="gist">Enter</span> to <span class="gist">eval()</span> the code you've typed in the input line.</li>
  <li><span class="gist">Arrow-up</span> and <span class="gist">Arrow-down</span> to move in the input line <span class="gist">history</span>.</li>
  </ul>
</dd>

<dt>Anywhere</dt>
<dd>
  <ul>
  <li><span class="gist">Control-R</span> <span class="gist">refreshes</span> the display. Useful if you eval'ed some code that changes the object inspected.</li>
  <li><span class="gist">Control-L</span> moves the keyboard focus to the eval <span class="gist">input</span> line.</li>
  </ul>
</dd>

</dl>

<h2>Launching an editor</h2>

<p>When you double-click a method, DrX launches the command <code>gedit +%d "%s"</code>
by default (%d and %s are substituted by the line-number
and file-name). If you wish to use some other editor, set your
'DRX_EDITOR_COMMAND' environment variable accordingly (or see the next section).</p>

<p>Note that <em>gedit</em> has a bug: it positions the cursor on the
correct line, but sometimes it doesn't update the display and shows the
first page of the file. If this happens, click arrow-up, then
arrow-down, to update the display. Or use some other editor.</p>

<p>DrX figures out a method's location by inspecting Ruby's internal
nodes. This functionality is contained in a small C extension built when
you install the DrX gem.</p>

<p>Of course, DrX can't figure out the location of a method written in C.</p>

<h2>The ~/.drxrc file</h2>

DrX lets you put your customizations in the file <code>~/.drxrc</code>. Here's an example:

<pre>
class Drx::TkGUI::Application
  def user_customizations
    @eval_result.height = 8
    @graph_opts[:size] = '60%'
    @graph_opts[:style] = 'crazy'
  end
end

Drx::TkGUI::EDITOR_COMMAND.replace('gvim +%d "%s"')
</pre>

<h2>Reporting bugs</h2>

<p>Please file bugs and support requests at the GitHub <a
href="http://github.com/mooffie/drx/issues">issue queue</a>. If it's
useful in any way (I doubt it), the RubyForge project page <a
href="http://rubyforge.org/projects/drx/">is here</a>.</p>

