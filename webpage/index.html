<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta http-equiv="Cache-Control" content="no-cache">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Dr. X -- The Good Doctor</title>
<link rel="stylesheet" href="index.css" type="text/css">
</head>

<h1>Dr. X</h1>

<a href="screenshot1.png"><img align="right" width="400" height="410" class="main"
  src="screenshot1.png" title="Screenshot showing Dr. X in action" /></a>

<p>"Dr. X", the good doctor, is a small <em>object inspector</em> with
some unique features. It's most suitable for programmers who wish to
understand Ruby's object model better. Key features:</p>

<ul>
<li>Exposes everything about a Ruby object: its 'klass', 'super',
'iv_tbl', 'm_tbl'. See your singletons with your very own eyes! <br />&nbsp;</li>
<li>Double-clicking on a method name launches an editor
and positions the cursor at the exact line in the file where the method is
defined. (Locating methods isn't done by parsing your source code but by
examining the Ruby interpreter internal nodes.)</li>
</ul>

<p class="error">
2009-02-03 I've released this software only today; Consider it alpha quality.
</p>

<h2>Installation</h2>

<p>Dr. X is shipped as a gem. At your system prompt type:</p>

<code>gem install drx</code>

<h2>Usage</h2>

<p>Just <code>require 'drx'</code> in your program and do
<code>some_object.see</code> to investigate that object.</p>

<h2>Requirements</h2>

<ul>
<li>MRI Ruby 1.8 (Code wasn't yet ported to Ruby 1.9).</li>
<li>Ability to compile Ruby C extenstions (Because Dr. X has some part written in C).</li>
<li>The Tk user interface toolkit.</li>
<li>The <a href="todo-update-this-link">graphviz</a> package installed (It's used to draw the diagrams).</li>
</ul>

<h2>Example 1: Seeing things</h2>

For our first example, let's suppose you have the following DataMapper code...

<pre>
require 'rubygems'
require 'dm-core'

#
# This is part of a blogging website. Users write posts. A post
# belongs to a user.
#

class Post
  include DataMapper::Resource
 
  property :post_id,  Serial
  property :title,    String
  property :body,     Text
  
  belongs_to :user
end

class User
  include DataMapper::Resource
 
  property :user_uid,  Serial
  property :name,      String
  property :mail,      String
end
</pre>

<p>...and you wish to know what a Post object consists of. You'd append the following code...</p>

<pre>
post = Post.new

require 'drx'
post.see
</pre>

<p>...and you'd get the window shown in the screenshot above (click to
enlarge). Admittedly, it's ugly, but that's because I've used Tk. In the
left pane you see the 'super' and 'klass' hierarchy. In the middle pane
you see the instance variables and in the right-most one you see the
methods.</p>

<p>The screenshot happens to have the DataMapper::Model class selected.
You can see the 'find_by_sql' and 'property' method on the right.</p>

<p>The screenshot clearly shows two distinct branches. The lower one, in
which DataMapper::Model appears, deals with the Post class singleton.
The upper one, in which DataMapper::Resource appears, deals with the Post
class itself.</p>

<h2>Example 2: Investigating things</h2>

<p>Let's talk more about our Post class. We only did <code>include
DataMapper::Resource</code> in its body and we see that it's acquired
gazillions of things. We want to know why this had happened.
Specifically, we want to know how DataMapper::Model got there. We
suspect that DataMapper::Resource does this magic in its
<code>#included</code>, and we want to verify this theory.</p>

<p>Let's inspect DataMapper::Resource more closely. Double-click it.
(That is, double-click the "{ include DataMapper::Resource }" line. Next,
we want to see if it has any <code>#included</code>. So lets examine its
singleton class. Click the "#&lt;Class:DataMapper::Resource&gt; 'S" line.</p>

<p>Indeed, we see an 'included' method (in the right-most pane). Let's
double click this method to bring up an editor. Dr. X is so smart that it
knows in which file and at what line a method is defined. Here's the
result (click to enlarge):</p>

<div align=center>
  <a href="screenshot2.png"><img width="530" height="380"
    src="screenshot2.png" title="Screenshot showing Dr. X in action" /></a>
</div>

<p>Yep, that <code>model.extend Model</code> line explains everything. The mystery was solved!</p>

<h2>Understanding Dr. X</h2>

<p>If you aren't familiar with how objects are represented internally in
Ruby, you may not feel comfortable with the left-most pane, the one that
shows a tree of 'super' and 'klass'.</p>

<p>What do 'super' and 'klass' stand for? Ruby stores objects in a C
struct. Here's its definition (from ruby.h):</p>

<pre>
struct RBasic {
    unsigned long flags;
    VALUE klass;
};

struct RObject {
    struct RBasic basic;
    struct st_table *iv_tbl;
};

struct RClass {
    struct RBasic basic;
    struct st_table *iv_tbl;
    struct st_table *m_tbl;
    VALUE super;
};
</pre>

<p>What Dr. X does is show you these four slots: the 'klass', the 'super',
the 'iv_tbl', and the 'm_tbl'.</p>

<h2>Key bindings</h2>

<dl>

<dt>The hierarchy pane</dt>
<dd>
  <ul>
  <li>Left-click on an object in the diagram to select this object. This updates the variables and methods panes to reflect this object.</li>
  <li>Right-click to move back in history.</li>
  <li>Double Left-click on an object in the diagram to make this object the tip of the diagram. This
      is only needed if want to see the 'klass' of an included module (in
      other words, if you want to see "the singleton of a module"), because
      this singleton is the 'klass' of an 'ICLS (anonymous class) and the UI
      by default doesn't show it to prevent clutter.</li>
  </li>
  </ul>
</dd>

<dt>The variables pane</dt>
<dd>
  <ul>
  <li>Double left-click on a variable to "see" it.</li>
  <li>Left-click on a variable to p() it.</li>
  <li>Right-click on a variable to pp() it.</li>
  </ul>
</dd>

<dt>The methods pane</dt>
<dd>
  <ul>
  <li>Double-click on a method to bring up an editor showing it.</li>
  </ul>
</dd>

</dl>

<h2>Launching an editor</h2>

<p>When you double-click a method, Dr. X launches a 'gedit +%d "%s"'
command by default (%d and %s are substituted by the line-number and
file-name). If you wish to use some other editor, set your
'DRX_EDITOR_COMMAND' environment variable accordingly.</p>

<p>If Dr. X fails to load your editor, inspect its STDOUT. Error
messages are written there.</p>

<p>You should pay attention to STDOUT anyway because it's where p()'s
and pp()'s output goes when you click on variables.</p> 

<h2>Reporting bugs</h2>

<p>Please file bugs and support requests at the RubyForge <a href="http://rubyforge.org/projects/drx/">website</a>.</p>
